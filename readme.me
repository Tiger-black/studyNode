什么是NodeJS

JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。
而对于需要独立运行的JS，NodeJS就是一个解析器。
每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情。
例如运行在浏览器中的JS的用途是操作DOM，浏览器就提供了document之类的内置对象。
而运行在NodeJS中的JS的用途是操作磁盘文件或搭建HTTP服务器，NodeJS就相应提供了fs、http等内置对象。

总结 
 1、NodeJS是一个JS脚本解析器，任何操作系统下安装NodeJS本质上做的事情都是把NodeJS执行程序复制到一个目录，
 然后保证这个目录在系统PATH环境变量下，以便终端下可以使用node命令。
 2、终端下直接输入node命令可进入命令交互模式，很适合用来测试一些JS代码片段，比如正则表达式。
 3、NodeJS使用CMD模块系统，主模块作为程序入口点，所有模块在执行过程中只初始化一次。
 4、除非JS模块不能满足需求，否则不要轻易使用二进制模块，否则你的用户会叫苦连天。


    /usr/local/bin/node  node的路径


一、原生开发命令工具
    模块路径解析规则
    require函数支持斜杠（/）或盘符（C:）开头的绝对路径，也支持./开头的相对路径。
    但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。
    因此，require函数支持第三种形式的路径，写法类似于foo/bar，并依次按照以下规则解析路径，直到找到模块位置。
    1、内置模块
        如果传递给require函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如require('fs')。

    2、node_modules目录 
        NodeJS定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是/home/user/hello.js，
        在该模块中使用require('foo/bar')方式加载模块时，则NodeJS依次尝试使用以下路径。
        /home/user/node_modules/foo/bar
        /home/node_modules/foo/bar
        /node_modules/foo/bar

    3、NODE_PATH环境变量
        与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。
        NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。
        例如定义了以下NODE_PATH环境变量： NODE_PATH=/home/user/lib:/home/lib
        当使用require('foo/bar')的方式加载模块时，则NodeJS依次尝试以下路径。/home/user/lib/foo/bar 或者 /home/lib/foo/bar
    
    4、编写一个命令行工具 例子 two/xiaohusay
        （1）首先，使用 JavaScript 语言，写一个可执行脚本，可以通过#!注释来指定当前脚本使用的解析器 顶部加一行代码 #!/usr/bin/env node NodeJS会忽略掉位于JS模块首行的#!注释，不必担心这行注释是非法语句。
        （2）然后，我们使用以下命令赋予node-echo.js文件执行权限。 $ chmod +x /home/user/bin/node-echo.js 或者 $ chmod 755 hello
        （3）最后，我们在PATH环境变量中指定的某个目录下，例如在/usr/local/bin下边创建一个软链文件，文件名与我们希望使用的终端命令同名，命令如下：
        $ sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo
        这样处理后，我们就可以在任何目录下使用node-echo命令了。
        另一种更好的做法，是在当前目录下新建 package.json ，写入下面的内容。
            {
                "name": "hello",
                "bin": {
                    "hello": "hello"
                }
            }  然后执行 npm link 命令。
    
    如果你已经 npm link 搞了一遍你再 link 一遍，会报如下错误。即使你 npm unlink 也会报错
    让你删除 /usr/local/bin/wcj 再 npm link ， 删除此目录运行 rm -rf /usr/local/bin/wcj

二、依赖 nodejs 原生开发命令工具比较麻烦，可以使用命令行框架帮助我们简化命令行开发。
    1、Commander 是一款重量轻，表现力强大的命令行框架。提供了用户命令行输入和参数解析强大功能。
        Commander 源自一个同名的Ruby项目。Commander.js 是 TJ 写的一个帮助快速开发Nodejs命令行工具的package。
        TJ这货是Nodejs社区里非常知名的高产作者。方便的定义option(包括option的描述和其回调函数)和子命令。

    2、shelljs 模块重新包装了 child_process，调用系统命令更加方便。它需要安装后使用。
        npm install --save shelljs
        然后，改写脚本。
        #!/usr/bin/env node
        var name = process.argv[2];
        var shell = require("shelljs");
        shell.exec("echo hello " + name);
        上面代码是 shelljs 的本地模式，即通过 exec 方法执行 shell 命令。此外还有全局模式，允许直接在脚本中写 shell 命令。
        require('shelljs/global');
        if (!which('git')) {
            echo('Sorry, this script requires git');
            exit(1);
        }
        mkdir('-p', 'out/Release');
        cp('-R', 'stuff/*', 'out/Release');
        cd('lib');
        ls('*.js').forEach(function(file) {
            sed('-i', 'BUILD_VERSION', 'v0.1.2', file);
            sed('-i', /.*REMOVE_THIS_LINE.*\n/, '', file);
            sed('-i', /.*REPLACE_LINE_WITH_MACRO.*\n/, cat('macro.js'), file);
        });
        cd('..');
        if (exec('git commit -am "Auto-commit"').code !== 0) {
            echo('Error: Git commit failed');
            exit(1);
        }

    3、 yargs 模块 
        shelljs 只解决了如何调用 shell 命令，而 yargs 模块能够解决如何处理命令行参数。它也需要安装。
        $ npm install --save yargs
        yargs 模块提供 argv 对象，用来读取命令行参数。请看改写后的 hello 。
        #!/usr/bin/env node
        var argv = require('yargs').argv;
        console.log('hello ', argv.name);

        process.argv 的原始返回值如下。
        $ node hello --name=tom
        [ 'node','/path/to/myscript.js','--name=tom' ]
        yargs 可以上面的结果改为一个对象，每个参数项就是一个键值对。
        $ node hello --name=tom
        argv = {name: tom};
        如果将 argv.name 改成 argv.n，就可以使用一个字母的短参数形式了。可以使用 alias 方法，指定 name 是 n 的别名。
        #!/usr/bin/env node
        var argv = require('yargs')
            .alias('n', 'name')
            .argv;
        console.log('hello ', argv.n);这样一来，短参数和长参数就都可以使用了。

        argv 对象有一个下划线（_）属性，可以获取非连词线开头的参数。 跟在 -X 后面的第一个参数不匹配 例如 -n a b c  下划线只匹配bc
        console.log(argv._);
        
        命令行参数的配置
        yargs 模块还提供3个方法，用来配置命令行参数。
        demand：是否必选
        default：默认值
        describe：提示
        #!/usr/bin/env node
        var argv = require('yargs')
            .demand(['n'])
            .default({n: 'tom'})
            .describe({n: 'your name'})
            .argv;
        console.log('hello ', argv.n);

        options 方法允许将所有这些配置写进一个对象。
        var argv = require('yargs')
        .option('n', {
            alias : 'name',
            demand: true,
            default: 'tom',
            describe: 'your name',
            type: 'string'
        })
        .argv;
        有时，某些参数不需要值，只起到一个开关作用，这时可以用 boolean 方法指定这些参数返回布尔值
        var argv = require('yargs')
            .boolean(['n'])
            .argv;
        boolean 方法也可以作为属性，写入 option 对象。
        .option('n', {
            boolean: true
        })

        yargs 模块提供以下方法，生成帮助信息。
        usage：用法格式
        example：提供例子
        help：显示帮助信息
        epilog：出现在帮助信息的结尾



        子命令 
            yargs 模块还允许通过 command 方法，设置 Git 风格的子命令。
            #!/usr/bin/env node
            var argv = require('yargs')
                .command("morning", "good morning", function (yargs) {
                    console.log("Good Morning");
                })
                .command("evening", "good evening", function (yargs) {
                    console.log("Good Evening");
                })
                .argv;

            console.log('hello ', argv.n);

            可以将这个功能与 shellojs 模块结合起来。
            #!/usr/bin/env node
            require('shelljs/global');
            var argv = require('yargs')
                .command("morning", "good morning", function (yargs) {
                    echo("Good Morning");
                })
                .command("evening", "good evening", function (yargs) {
                    echo("Good Evening");
                })
                .argv;

            console.log('hello ', argv.n);

        每个子命令往往有自己的参数，这时就需要在回调函数中单独指定。回调函数中，要先用 reset 方法重置 yargs 对象。

        #!/usr/bin/env node
            require('shelljs/global');
            var argv = require('yargs')
                .command("morning", "good morning", function (yargs) {  
                    echo("Good Morning");
                    var argv = yargs.reset()
                    .option("m", {
                        alias: "message",
                        description: "provide any sentence"
                    })
                    .help("h")
                    .alias("h", "help")
                    .argv;

                    echo(argv.m);
                })
                .argv;

    4、其他事项
        （1）返回值
            根据 Unix 传统，程序执行成功返回 0，否则返回 1 。
            if (err) {
                process.exit(1);
            } else {
                process.exit(0);
            }

        （2）重定向
            Unix 允许程序之间使用管道重定向数据。
            $ ps aux | grep 'node'
            脚本可以通过监听标准输入的data 事件，获取重定向的数据。
            process.stdin.resume();
            process.stdin.setEncoding('utf8');
            process.stdin.on('data', function(data) {
                process.stdout.write(data);
            });
            下面是用法。
            $ echo 'foo' | ./hello
            hello foo
        （3）系统信号
        操作系统可以向执行中的进程发送信号，process 对象能够监听信号事件。
        process.on('SIGINT', function () {
            console.log('Got a SIGINT');
            process.exit(0);
        });

        发送信号的方法如下。
        $ kill -s SIGINT [process_id]

     注意 
        1、命名不要太随意,避免重复
        2、有的时候cnpm 装的包不完整，需要执行npm
        3、没有仓库会报错 可以设置"repository": {"private": true},
        4、创建js的时候一定要先给与js文件设置权限
        5、妈的 这句一定要写对 #!/usr/bin/env node ！！！！！！！！ 不能有空格 找了一天问题
三、文件操作 File System [fail ˈsistəm]
    让前端觉得如获神器的不是NodeJS能做网络编程，而是NodeJS能够操作文件。
    小至文件查找，大至代码编译，几乎没有一个前端工具不操作文件。
    换个角度讲，几乎也只需要一些数据处理逻辑，再加上一些文件操作，就能够编写出大多数前端工具。本章将介绍与之相关的NodeJS内置模块。
    开门红

    1、NodeJS提供了基本的文件操作API，但是像文件拷贝这种高级功能就没有提供，因此我们先拿文件拷贝程序练手。
    与copy命令类似，我们的程序需要能接受源文件路径与目标文件路径两个参数。
        小文件拷贝
            我们使用NodeJS内置的fs模块简单实现这个程序如下。
            var fs = require('fs');
            function copy(src, dst) {
                fs.writeFileSync(dst, fs.readFileSync(src));
            }
            function main(argv) {
                copy(argv[0], argv[1]);
            }
            main(process.argv.slice(2));
            以上程序使用fs.readFileSync 从源路径读取文件内容，并使用fs.writeFileSync 将文件内容写入目标路径。
            
            readFileSync 同步版的fs.writeFile()  fs.writeFileSync(filename, data, [options])
            接收参数：
                filename      (String)            文件名称
                data        (String | Buffer)    将要写入的内容，可以使字符串 或 buffer数据。
                options        (Object)           option数组对象，包含：
                · encoding   (string)            可选值，默认 ‘utf8′，当data使buffer时，该值应该为 ignored。
                · mode         (Number)        文件读写权限，默认值 438
                · flag            (String)            默认值 ‘w'
            实现源码 fs.writeFileSync = function(path, data, options) {
                if (!options) {
                    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'w' };
                } else if (util.isString(options)) {
                    options = { encoding: options, mode: 438, flag: 'w' };
                } else if (!util.isObject(options)) {
                    throw new TypeError('Bad arguments');
                }
                assertEncoding(options.encoding);
                var flag = options.flag || 'w';
                var fd = fs.openSync(path, flag, options.mode);
                if (!util.isBuffer(data)) {
                    data = new Buffer('' + data, options.encoding || 'utf8');
                }
                var written = 0;
                var length = data.length;
                var position = /a/.test(flag) ? null : 0;
                try {
                    while (written < length) {
                    written += fs.writeSync(fd, data, written, length - written, position);
                    position += written;
                    }
                } finally {
                    fs.closeSync(fd);
                }
            };
    process是一个全局变量，可通过process.argv获得命令行参数。
    由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，(mode路径，当前主模块绝对路径)
    因此第一个命令行参数从argv[2]这个位置开始
        大文件拷贝
            上边的程序拷贝一些小文件没啥问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。
            对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如下。
            var fs = require('fs');

            function copy(src, dst) {
                fs.createReadStream(src).pipe(fs.createWriteStream(dst));
            }

            function main(argv) {
                copy(argv[0], argv[1]);
            }

            main(process.argv.slice(2));
            以上程序使用fs.createReadStream创建了一个源文件的只读数据流，并使用fs.createWriteStream创建了一个目标文件的只写数据流，并且用pipe方法把两个数据流连接了起来。连接起来后发生的事情，说得抽象点的话，水顺着水管从一个桶流到了另一个桶。
   2、API走马观花
        我们先大致看看NodeJS提供了哪些和文件操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。
        (1) Buffer      （数据块）官方文档： http://nodejs.org/api/buffer.html
            JS语言自身只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据的操作。
            除了可以读取文件得到Buffer的实例外，还能够直接构造，例如：var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]); 
            Buffer与字符串类似，除了可以用.length属性得到字节长度外，还可以用[index]方式读取指定位置的字节，例如：bin[0]; // => 0x68;
            Buffer与字符串能够互相转化，例如可以使用指定编码将二进制数据转化为字符串：var str = bin.toString('utf-8'); // => "hello"
            或者反过来，将字符串转换为指定编码下的二进制数据：var bin = new Buffer('hello', 'utf-8'); // => <Buffer 68 65 6c 6c 6f>
            Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于Buffer，更像是可以做指针操作的C语言数组。
            例如，可以用[index]方式直接修改某个位置的字节。

            bin[0] = 0x48;
            而.slice方法也不是返回一个新的Buffer，而更像是返回了指向原Buffer中间的某个位置的指针，如下所示。

            [ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]
                ^           ^
                |           |
            bin     bin.slice(2)

            因此对.slice方法返回的Buffer的修改会作用于原Buffer，例如：
            var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
            var sub = bin.slice(2);

            sub[0] = 0x65;
            console.log(bin); // => <Buffer 68 65 65 6c 6f>

            也因此，如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。
            这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子。
            var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
            var dup = new Buffer(bin.length);

            bin.copy(dup);
            dup[0] = 0x48;
            console.log(bin); // => <Buffer 68 65 6c 6c 6f>
            console.log(dup); // => <Buffer 48 65 65 6c 6f>
            总之，Buffer将JS的数据处理能力从字符串扩展到了任意二进制数据。
        (2) Stream      （数据流）官方文档： http://nodejs.org/api/stream.html
            当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种Stream来提供对数据流的操作。
            var rs = fs.createReadStream(pathname);
            rs.on('data', function (chunk) {
                doSomething(chunk);
            });
            rs.on('end', function () {
                cleanUp();
            });
            Stream基于事件机制工作，所有Stream的实例都继承于NodeJS提供的EventEmitter。https://nodejs.org/api/events.html

            上边的代码中data事件会源源不断地被触发，不管doSomething函数是否处理得过来。代码可以继续做如下改造，以解决这个问题。
            var rs = fs.createReadStream(src);
            rs.on('data', function (chunk) {
                rs.pause();
                doSomething(chunk, function () {
                    rs.resume();
                });
            });
            rs.on('end', function () {
                cleanUp();
            });


            stream.pause();     暂停流 [pɔ:z]
            stream.resume();   恢复流 [rɪ'zju:m]


            以上代码给 doSomething 函数加上了回调，因此我们可以在处理数据前暂停数据读取，并在处理数据后继续读取数据。

            此外，我们也可以为数据目标创建一个只写数据流，示例如下：
            var rs = fs.createReadStream(src);
            var ws = fs.createWriteStream(dst);

            rs.on('data', function (chunk) {
                ws.write(chunk);
            });

            rs.on('end', function () {
                ws.end();
            });
            我们把doSomething换成了往只写数据流里写入数据后，以上代码看起来就像是一个文件拷贝程序了。
            但是以上代码存在上边提到的问题，如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。
            我们可以根据.write方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据drain事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。
            因此代码可以改造如下：
            var rs = fs.createReadStream(src);
            var ws = fs.createWriteStream(dst);

            rs.on('data', function (chunk) {
                if (ws.write(chunk) === false) {
                    rs.pause();
                }
            });

            rs.on('end', function () {
                ws.end();
            });

            ws.on('drain', function () {
                rs.resume();
            });
            以上代码实现了数据从只读数据流到只写数据流的搬运，并包括了防爆仓控制。因为这种使用场景很多，例如上边的大文件拷贝程序
            NodeJS直接提供了.pipe方法来做这件事情，其内部实现方式与上边的代码类似。
        (3) File System （文件系统）官方文档： http://nodejs.org/api/fs.html
            NodeJS通过fs内置模块提供对文件的操作。fs模块提供的API基本上可以分为以下三类：
            文件属性读写。
                其中常用的有fs.stat 、fs.chmod 、fs.chown 等等。

            文件内容读写。
                其中常用的有fs.readFile 、fs.readdir 、fs.writeFile 、fs.mkdir 等等。

            底层文件操作。
                其中常用的有fs.open 、fs.read 、fs.write 、fs.close 等等。
            
            NodeJS最精华的异步IO模型在fs模块里有着充分的体现，例如上边提到的这些API都通过回调函数传递结果。以fs.readFile为例：
            fs.readFile(pathname, function (err, data) {
                if (err) {
                    // Deal with error.
                } else {
                    // Deal with data.
                }
            });
            如上边代码所示，基本上所有fs模块API的回调参数都有两个。第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果。
            此外，fs模块的所有异步API都有对应的同步版本，用于无法使用异步操作时，或者同步操作更方便时的情况。
            同步API除了方法名的末尾多了一个Sync之外，异常对象与执行结果的传递方式也有相应变化。同样以fs.readFileSync为例：
            try {
                var data = fs.readFileSync(pathname);
                // Deal with data.
            } catch (err) {
                // Deal with error.
            }
            fs模块提供的API很多，这里不一一介绍，需要时请自行查阅官方文档。
        (3) Path        （路径）官方文档： http://nodejs.org/api/path.html
            操作文件时难免不与文件路径打交道。NodeJS提供了path内置模块来简化路径相关操作，并提升代码可读性。以下分别介绍几个常用的API。
            path.normalize 生成标准路径  [ˈnɔ:məlaɪz] 
                将传入的路径转换为标准路径，具体讲的话，除了解析路径中的.与..外，还能去掉多余的斜杠。
                如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。以下是一个例子：
                var cache = {};

                function store(key, value) {
                    cache[path.normalize(key)] = value;
                }

                store('foo/bar', 1);
                store('foo//baz//../bar', 2);
                console.log(cache);  // => { "foo/bar": 2 }
                
                坑出没注意： 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, '/')再替换一下标准路径。
            
            path.join 拼接路径
                将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。以下是一个例子：
                path.join('foo/', 'baz/', '../bar'); // => "foo/bar"
            path.extname 获取后缀名
                当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。以下是一个例子：
                path.extname('foo/bar.js'); // => ".js"
            path模块提供的其余方法也不多，稍微看一下官方文档就能全部掌握。

   3、遍历目录
        遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。
        (1) 递归算法
            遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法。
            function factorial(n) {
                if (n === 1) {
                    return 1;
                } else {
                    return n * factorial(n - 1);
                }
            }
            上边的函数用于计算N的阶乘（N!）。可以看到，当N大于1时，问题简化为计算N乘以N-1的阶乘。当N等于1时，问题达到最小规模，不需要再简化，因此直接返回1。
            陷阱： 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。
        (2) 遍历算法
            目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。
            先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是A > B > D > E > C > F。

                     A
                    / \
                   B   C
                  / \   \
                 D   E   F
            同步遍历
                了解了必要的算法后，我们可以简单地实现以下目录遍历函数。
                function travel(dir, callback) {
                    fs.readdirSync(dir).forEach(function (file) {
                        var pathname = path.join(dir, file);

                        if (fs.statSync(pathname).isDirectory()) {
                            travel(pathname, callback);
                        } else {
                            callback(pathname);
                        }
                    });
                }
                可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。
            异步遍历
                如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。travel函数的异步版本如下。
                function travel(dir, callback, finish) {
                    fs.readdir(dir, function (err, files) {
                        (function next(i) {
                            if (i < files.length) {
                                var pathname = path.join(dir, files[i]);
                                fs.stat(pathname, function (err, stats) {
                                    if (stats.isDirectory()) {
                                        travel(pathname, callback, function () {
                                            next(i + 1);
                                        });
                                    } else {
                                        callback(pathname, function () {
                                            next(i + 1);
                                        });
                                    }
                                });
                            } else {
                                finish && finish();
                            }
                        }(0));
                    });
                }
                travel("../",function(pathname,func){
                    console.log(pathname);
                    func();
                },function(){
                    console.log("遍历完成");
                });
                闭包实现
                利用readdir读取所有子目录名
                读取完成进行回调，先检查第一项，利用path.join()得到当前的目录/文件名
                利用fs.stat()检测当前项是目录还是文件夹，是文件夹，以当前目录执行递归；是文件，检查第二项
                当一个目录中的所有项都被遍历后，返回上级目录，开始遍历上级目录的下一项。
                遍历完成：输出遍历完成。
                这里不详细介绍异步遍历函数的编写技巧，在后续章节中会详细介绍这个。总之我们可以看到异步编程还是蛮复杂的。
